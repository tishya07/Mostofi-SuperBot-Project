def calculate_torso_contour(S, f_band, gamma = 0.03):
    """
    S: denoised spectrogram
    gamma (in percent): threshold for energy ratio of FFT
    f_ref: frequency vector of the spectrogram
    returns 
    freq_tc: torso contour frequency
    """
    #energy at each time slice
    energy = np.sum(S, axis = 0) + 1e-12
    #energy ratio per frequency per time
    energy_ratio = S / energy[None,:]
    freq_tc = np.zeros(S.shape[1])

    for t in range(S.shape[1]):
        index = np.where(energy_ratio[:,t] > gamma)[0]
        if len(index) > 0:
            freq_tc[t] = f_band[index].max()
        else:
            freq_tc[t] = 0
    return freq_tc


def calculate_movement_speed(S, t, f, percentile=0.5):
    """
    S: spectrogram magnitudes
    t: time vector
    f: frequency vector
    percentile: threshold. percentile >=50 is torso, percentile >= 95 is limb
    """
    n_freq, n_time = S.shape
    freq_speed = np.zeros(n_time)
    cumulative_energy = np.cumsum(S, axis = 0)

    #last row = total energy per time
    total_energy = cumulative_energy[-1, :] + 1e-12

    P = cumulative_energy / total_energy[None, :]

    for t_idx in range(n_time):
        idx = np.where(P[:, t_idx] >= percentile)[0]
        if len(idx) > 0:
            freq_speed[t_idx] = f[idx[0]]
        else:
            freq_speed[t_idx] = 0
    
    return freq_speed

def plot_spectrogram_overlay(S, t, f, 
                            freq_tc=None, 
                            torso_speed=None, 
                            limb_speed=None):
                            
    plt.figure(figsize=(9,4.5))
    extent = [t[0], t[-1], f[0], f[-1]]

    # Spectrogram
    plt.pcolormesh(t, f, S, shading='gouraud')
    plt.colorbar(label='Magnitude (linear)')
    plt.xlabel("Time (s)")
    plt.ylabel("Frequency (Hz)")
    plt.ylim([15, 100])

    plt.title("Feature Extraction Overlay")

    # Overlay feature extraction
    if freq_tc is not None:
        plt.plot(t, freq_tc, color='red', linewidth=1, label="Torso contour frequency")
    if torso_speed is not None:
            plt.plot(t, torso_speed, color='yellow', linewidth=1, label="Torso speed (50%)")
    if limb_speed is not None:
            plt.plot(t, limb_speed, color='pink', linewidth=1, label="Limb speed (95%)")

    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_spectrogram_speeds(S, t, f, 
                            freq_tc,
                            torso_speed,
                            limb_speed):
    
    fig, axes = plt.subplots(1, 2, figsize=(16, 5), gridspec_kw={'width_ratios': [2.3, 1]})
    ax = axes[0]
    extent = [t[0], t[-1], f[0], f[-1]]
    im = ax.imshow(S,
                   aspect='auto',
                   origin='lower',
                   extent=extent,
                   interpolation='nearest')

    ax.set_title("Spectrogram", fontsize=13)
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Frequency (Hz)")
    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label("Magnitude")
    ax2 = axes[1]
    ax2.plot(t, freq_tc, color='red', label="Torso contour", linewidth=1.3)
    if torso_speed is not None:
        ax2.plot(t, torso_speed, color='yellow', label="Torso speed (50%)", linewidth=1.3)
    if limb_speed is not None:
        ax2.plot(t, limb_speed, color='pink', label="Limb speed (95%)", linewidth=1.3)
    ax2.set_title("Extracted Speed Features", fontsize=13)
    ax2.set_xlabel("Time (s)")
    ax2.set_ylabel("Frequency (Hz)")
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc="upper right", fontsize=9)

    plt.tight_layout()
    plt.show()



torso_speed = calculate_movement_speed(mag, t, f, percentile=0.5)
limb_speed = calculate_movement_speed(mag, t, f, percentile=0.95)

plot_spectrogram_overlay(mag, t, f, torso_speed=torso_speed, limb_speed=limb_speed)
plot_spectrogram_speeds(mag, t, f, freq_tc, torso_speed, limb_speed)



###### Segmentation method (used on spectrogram generated by code currently in spectrogram.py 11/26 ######
#just to make sure not attached to older stuff
f = f_band
t = t_ref
mag = S_eq  
# Functions:
      
# Function to extract frequency and generalized speed curve
# Speed curve is not accurate over whole walk due to psi not constant
# Will be used to find the constant psi segment
def extract_bodypart_percentile(f,          
                                   t,          
                                   S,          
                                   fc_hz=5.32e9,   # Center carrier frequency
                                   pct=0.5,        # Energy percentile for desired body part (50% - torso, 90% - leg)
                                   f_min=5.0,      # Minimum frequency to consider as bodypart-related
                                   f_max=60.0,     # Maximum frequency to consider as bodypart-related
                                   smooth_sigma=3  # Std dev for Gaussian smoothing along time
                                   ):

    # number of frequency and time bins from the spectrogram 
    n_freqs, n_times = S.shape

    # Create a boolean mask to select frequencies in the band
    freq_mask = (f >= f_min) & (f <= f_max)
    f_bodypart_band = f[freq_mask] 
    S_bodypart_band = S[freq_mask, :] 
    # Ditch potentially neg vals
    S_bodypart_band = np.maximum(S_bodypart_band, 0.0)

    # Cumulative energy along the frequency axis for each time bin
    cum_energy = np.cumsum(S_bodypart_band, axis=0) 
    # Total energy per time bin 
    total_energy = cum_energy[-1, :] 
    total_energy = total_energy + 1e-12 
    # Normalize cumulative energy 
    cum_energy_norm = cum_energy / total_energy[np.newaxis, :]  

    # Array to hold the torso frequency at each time bin 
    f_bodypart_raw = np.full(n_times, np.nan, dtype=float) 

    # For each time index, find the smallest frequency where cumulative energy >= percentile
    for ti in range(n_times):  # loop over time bins
        # Extract the normalized cumulative energy curve for time bin
        c_t = cum_energy_norm[:, ti]  

        # Find indices where the cumulative energy is at least threshold 
        idx_candidates = np.where(c_t >= pct)[0]
        # skip bin if all too small
        if idx_candidates.size == 0:
            continue  

        # First index to cross threshold
        idx = idx_candidates[0]
        # Collect corresponding frequency
        f_bodypart_raw[ti] = f_bodypart_band[idx]

    # Compute the wavelength from the center frequency using λ = c / f
    c = 3.0e8  # speed of light in m/s
    wavelength = c / fc_hz  # meters

    # Convert frequency to speed 
    v_bodypart_raw = 0.5 * wavelength * f_bodypart_raw 

    # Optionally smooth with Gaussian filter 
    v_bodypart_smooth = gaussian_filter1d(v_bodypart_raw, sigma=smooth_sigma)

    # Return time axis, smoothed speed curve, and raw frequencies
    return t, v_bodypart_smooth, f_bodypart_raw


# Function to compute variance per time slice Vth for psi segment
def compute_spectral_variance(f,        
                              S,        
                              f_min=5.0,# min freq to include in var calculation
                              f_max=60.0# max freq to include in var calculation
                              ):
    # Create a boolean mask to select frequencies in the band
    freq_mask = (f >= f_min) & (f <= f_max)
    f_bodypart_band = f[freq_mask] 
    S_bodypart_band = S[freq_mask, :] 
    # Ditch potentially neg vals
    S_bodypart_band = np.maximum(S_bodypart_band, 0.0)

    # Total energy per time slice
    energy_t = np.sum(S_bodypart_band, axis=0)  
    energy_t = energy_t + 1e-12   

    # Normalize each column 
    P = S_bodypart_band / energy_t[np.newaxis, :]  

    # Mean frequency for each time
    mu_f = np.sum(f_bodypart_band[:, np.newaxis] * P, axis=0)  

    # Compute the second moment for each time
    second_moment = np.sum((f_bodypart_band[:, np.newaxis]**2) * P, axis=0) 

    # Variance 
    V = second_moment - mu_f**2 

    # Force any tiny negative numerical noise to zero
    V = np.maximum(V, 0.0)

    # Return variance per time
    return V

# Function to find segments of at least 3s of true in boolean array
def find_boolean_segments(mask, t, min_duration=3.0):
    
    # Number of time points
    n = mask.size

    # If there are no True values at all, return empty list
    if n == 0 or not mask.any():
        return []

    # Difference between consecutive mask values
    diff = np.diff(mask.astype(int))
    # Indices where segments start: where diff == +1 
    # (shift by +1 for actual start index),
    # plus index 0 if mask[0] is already True
    starts = list(np.where(diff == 1)[0] + 1)
    if mask[0]:
        starts.insert(0, 0)
    # Indices where segments end: where diff == -1, 
    # plus the last index if mask[-1] is True
    ends = list(np.where(diff == -1)[0])
    if mask[-1]:
        ends.append(n - 1)

    # List to store valid segments 
    segments = []

    # Loop over each start/end pair
    for s_idx, e_idx in zip(starts, ends):
        # Convert index range to time range
        t_start = t[s_idx]
        t_end   = t[e_idx]

        # Duration of segment
        duration = t_end - t_start

        # Keep only segments long enough
        if duration >= min_duration:
            segments.append((t_start, t_end, s_idx, e_idx))

    # Return all segments that satisfy duration constraint
    return segments

# Implementation
#Find constant psi segment in the walk (update to segments if works well)
# Use more stable (torso) bodypart to choose segment
t_torso, v_torso, f_torso = extract_bodypart_percentile(
    f=f,             # frequency bins from STFT
    t=t,             # time bins from STFT
    S=mag,           # spectrogram magnitude
    fc_hz=5.32e9,    # center frequency 
    pct=0.5,         # 50% energy percentile for torso 
    f_min=5.0,       
    f_max=60.0,    
    smooth_sigma=3   # smoothing strength for Gaussian
)

# Apply smoothing
v_torso_smooth2 = gaussian_filter1d(v_torso, sigma=8)

# Local torso speed stability 
# rolling local mean using a 2-second smoothing
v_local_mean = gaussian_filter1d(v_torso_smooth2, sigma=15)

# Allowed deviation
v_dev_thresh = 0.45   # increased from 0.3 in Xmodal

# Mask of where speed is near local mean 
mask_stable_speed = np.abs(v_torso_smooth2 - v_local_mean) < v_dev_thresh

# Ditch invalid speeds
mask_stable_speed &= (v_torso_smooth2 > 0.3) & (v_torso_smooth2 < 2.5)

# Spectral variance 
V_t = compute_spectral_variance(f=f, S=mag, f_min=5.0, f_max=60.0)
# Variance threshold .9 vs .8 in Xmodal
V_thresh = np.percentile(V_t, 90)  
mask_low_variance = V_t <= V_thresh

# Either condition to identify regions
mask_candidate = mask_low_variance | mask_stable_speed

# Regions >= 3 secs
segments_pre = find_boolean_segments(mask_candidate, t, min_duration=3.0)

# If none -> stop
if len(segments_pre) == 0:
    print("No segments found — change thresholds")
    mask_best_segment = np.zeros_like(mask_candidate)
else:
    # Choose longest candidate segment
    durations = [seg[1] - seg[0] for seg in segments_pre]
    best_idx = int(np.argmax(durations))
    t_start_best, t_end_best, i_start, i_end = segments_pre[best_idx]

    # Refine segment using both conditions 
    mask_refined = mask_low_variance & mask_stable_speed

    # Build mask only in refined window
    mask_best_segment = np.zeros_like(mask_refined, dtype=bool)
    mask_best_segment[i_start:i_end+1] = mask_refined[i_start:i_end+1]

    # Ensure refined segment is at least 3 seconds
    final_segments = find_boolean_segments(mask_best_segment, t, min_duration=3.0)

    if len(final_segments) == 0:
        print("Refined segment too short reverting to former segment")
        mask_best_segment = np.zeros_like(mask_candidate)
        mask_best_segment[i_start:i_end+1] = True
        t_start_best, t_end_best = t_start_best, t_end_best
    else:
        # Pick longest refined segment
        durations2 = [seg[1] - seg[0] for seg in final_segments]
        best2 = int(np.argmax(durations2))
        t_start_best, t_end_best, i_start2, i_end2 = final_segments[best2]
        mask_best_segment = np.zeros_like(mask_candidate)
        mask_best_segment[i_start2:i_end2+1] = True

# Plot spectrogram with selected constant-ψ window
plt.figure(figsize=(14, 6))
plt.pcolormesh(t, f, mag, shading='gouraud', cmap='viridis')
plt.ylim([0, 100])
plt.xlabel("Time [s]")
plt.ylabel("Frequency [Hz]")
plt.title("Spectrogram with Constant-ψ Segment Overlay")
cbar = plt.colorbar()
cbar.set_label("Magnitude")

# Draw vertical dashed lines at its start and end times
if t_start_best is not None:
    plt.axvline(t_start_best, color='w', linestyle='--', linewidth=2, label='Constant-ψ start')
    plt.axvline(t_end_best,   color='r', linestyle='--', linewidth=2, label='Constant-ψ end')
    plt.legend()

plt.tight_layout()
plt.show()


# Crop walk to constant segment
mag_seg = mag[:, mask_best_segment]        # spectrogram restricted to segment
t_seg   = t[mask_best_segment]             # time values
v_seg   = v_torso[mask_best_segment]       # torso-speed values

# Torso and Limb Feature Extraction on Constant Segment
# Torso
t_torso_seg, v_torso_seg, f_torso_seg = extract_bodypart_percentile(
    f=f,             # same frequency bins as STFT
    t=t_seg,         # segmented time axis
    S=mag_seg,       # segmented spectrogram
    fc_hz=5.32e9,     # Center carrier frequency
    pct=0.5,         # 50% percentile for torso
    f_min=5.0,       
    f_max=60.0,      # typical torso band upper bound
    smooth_sigma=3   
)

# Limb
t_limb_seg, v_limb_seg, f_limb_seg = extract_bodypart_percentile(
    f=f,             
    t=t_seg,        
    S=mag_seg,      
    fc_hz=5.32e9,    
    pct=0.95,        # 95% percentile for limbs 
    f_min=5.0,      
    f_max=80.0,      # allow a bit higher band for limbs
    smooth_sigma=3  
)

# Extra smoothing for plotting  
f_torso_seg_smooth = gaussian_filter1d(f_torso_seg, sigma=2)
f_limb_seg_smooth  = gaussian_filter1d(f_limb_seg,  sigma=2)

# Duration of constant segment
T_seg = t_seg[-1] - t_seg[0] if t_seg.size > 1 else 0.0

# Mean torso speed (m/s)
v_torso_mean = np.nanmean(v_torso_seg)

# Standard deviation of torso speed (m/s)
v_torso_std  = np.nanstd(v_torso_seg)

# Mean limb speed (m/s)
v_limb_mean  = np.nanmean(v_limb_seg)

# Standard deviation of limb speed (m/s)
v_limb_std   = np.nanstd(v_limb_seg)

# Ratio of mean limb and torso speeds 
v_ratio = v_limb_mean / (v_torso_mean + 1e-9)

print("\n=== Basic Gait Features (Constant-ψ Segment) ===")
print(f"Segment duration         : {T_seg:.2f} s")
print(f"Mean torso speed         : {v_torso_mean:.3f} m/s")
print(f"Torso speed std          : {v_torso_std:.3f} m/s")
print(f"Mean limb speed          : {v_limb_mean:.3f} m/s")
print(f"Limb speed std           : {v_limb_std:.3f} m/s")
print(f"Limb/Torso mean ratio    : {v_ratio:.3f}")

# Plot
plt.figure(figsize=(12, 5))

# Plot segment of spectrogram 
plt.pcolormesh(
    t_seg,             
    f,                 
    mag_seg,           
    shading='gouraud', 
    cmap='viridis'     
)
plt.ylim([0, 100])
plt.xlabel("Time [s]")       
plt.ylabel("Frequency [Hz]") 
plt.title("Constant-ψ Segment: Torso & Limb")
cbar = plt.colorbar()
cbar.set_label("Magnitude (linear)")

# Torso 
plt.plot(
    t_seg,                 
    f_torso_seg_smooth,    
    color='yellow',        
    linewidth=1.5,         
    label="Torso speed (50%)"
)

# Limb 
plt.plot(
    t_seg,                 
    f_limb_seg_smooth,     
    color='pink',          
    linewidth=1.2,         
    label="Limb speed (95%)"
)
plt.legend(loc='upper right')
plt.tight_layout()
plt.show()
